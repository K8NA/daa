
Teste pratico 2

------------------------DFS------------------------

// Exemplo de pesquisa em profundidade (DFS) num grafo nao dirigido

import java.util.*;
import java.io.*;

public class DFS {
    static int n;              // Numero de nos do grafo
    static boolean adj[][];    // Matriz de adjacencias
    static boolean visited[];  // Que nos ja foram visitados?

    static void dfs(int v) {
    	System.out.print(v + " ");
    	visited[v] = true;
    	for (int i=1; i<=n; i++)
  	    if (adj[v][i] && !visited[i])
  		    dfs(i);
    }

    public static void main(String args[]) {
    	Scanner stdin = new Scanner(System.in);

    	n       = stdin.nextInt();
    	adj     = new boolean[n+1][n+1];
    	visited = new boolean[n+1];
    	int edges = stdin.nextInt();
    	for (int i=0; i<edges; i++) {
  	    int a = stdin.nextInt();
  	    int b = stdin.nextInt();
  	    adj[a][b] = adj[b][a] = true;
    	}

      //so visita uma componente conexa
    	dfs(1); // Pesquisa em profundidade a partir do no 1
    	System.out.println();
    }
}



------------------------DAA025------------------------

// Dado um conjunto de pontos de contacto e as suas respectivas ligações, 
// descobrir o número de redes diferentes que existem no circuito. 

import java.util.*;
import java.io.*;


public class DAA025 {
  public static final int MAX = 101;

  static int n;              // Numero de nos do grafo
  static boolean adj[][];    // Matriz de adjacencias
  static boolean visited[];  // Que nos ja foram visitados?

  static void dfs(int v) {
    visited[v] = true;
    for (int i=1; i<=n; i++)
      if (adj[v][i] && !visited[i])
        dfs(i);
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);

    n = in.nextInt(); //pontos de contacto
    int l = in.nextInt(); //ligacoes exictentes

    adj     = new boolean[MAX][MAX]; // Matriz de adjacencias
    visited = new boolean[MAX];  // Que nos ja foram visitados?
    int redes = 0;

    for (int i=0; i<l; i++) {
      int a = in.nextInt();
      int b = in.nextInt();
      adj[a][b] = adj[b][a] = true;
    }

    for (int i=1; i<=n; i++) {
      if (!visited[i]) {
       redes++;
       dfs(i); // Pesquisa em profundidade a partir do no i
      }
    }
    System.out.println(redes);
  }
}



------------------------DAA026------------------------

// Dado o estado de várias culturas de micróbios (indicados por uma matriz de células),
// descobrir qual o tamanho do maior micróbio em cada uma delas, ou seja,
//qual o tamanho do maior conjunto conexo de células em cada caso.

import java.util.*;
import java.io.*;

public class DAA026 {
   static int lin;
   static int col;
   static char matriz[][];
   static boolean visitado[][];

   //tam do segmento que inclui a celula (x,y)
   static int size (int x, int y) {
      if (x<0 || x>=lin || y<0 || y>=col) return 0; //fora dos limites
      if (matriz[x][y] == '.') return 0; //celula vazia
      if (visitado[x][y]) return 0;  //celula ja visitada
      int count = 1; //celula nao vazia
      visitado[x][y] = true; //marcar como visitada
       count += size(x-1, y);
       count += size(x-1, y+1);
       count += size(x-1, y-1);
       count += size(x+1, y);
       count += size(x+1, y+1);
       count += size(x+1, y-1);
       count += size(x, y+1);
       count += size(x, y-1);
      return count;
   }

   public static void main(String[] args) {
      Scanner in = new Scanner(System.in);
      int max = 0;
      int n = in.nextInt(); //casos a considerar
      for (int k=0; k<n; k++) {
        lin = in.nextInt();
        col = in.nextInt();
        matriz   = new char[lin][col];
        visitado = new boolean[lin][col];
        for (int i=0; i<lin; i++)
          matriz[i] = in.next().toCharArray();
        for (int l=0; l<lin; l++) {
          for (int c=0; c<col; c++) {
            int cur = size(l,c);
            if (max < cur)
              max = cur;
          }
        }
        System.out.println(max);
        max = 0;
        for (int a=0; a<lin; a++)
          for (int b=0; b<col; b++)
            visitado[a][b] = false;
      }
    }
}

------------------------DAA027------------------------

// Dados vários grafos não dirigidos, 
// indicar se cada um deles é ou não bipartido.

import java.util.*;
import java.io.*;

public class DAA027 {
  static int MAX = 51;
  static int naoVis = 0;
  static int green = 1;
  static int red = 2;
  static int v, e, cor;
  static boolean adj[][] = new boolean[MAX][MAX];
  static int partido[] = new int[MAX];

  public static boolean partir(int a, int cor) {
    int newCor = (cor == green) ? red : green;
    if (partido[a] != naoVis) {
      if (partido[a] != newCor)
        return false;
      return true;
    }
    if (partido[a] == naoVis) {
      partido[a] = newCor;
      for (int i=0; i<v; i++)
        if (adj[a][i] == true)
          if (!partir(i, newCor))
            return false;
    }
    return true;
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt(); //num de casos

    for (int c=0; c<n; c++) {
      v = in.nextInt(); //num de nos
      e = in.nextInt(); //num de arestas
      for (int i=0; i<e; i++) {
        int a = in.nextInt();
        int b = in.nextInt();
        a--; b--;
        adj[a][b] = adj[b][a] = true;
      }

      boolean bipartido = partir(0, green);
      if (bipartido)
        System.out.println("sim");
      else
        System.out.println("nao");

      //reset
      for (int j=0; j<v; j++) {
        for (int k=0; k<v; k++)
          adj[j][k] = false;
        partido[j] = naoVis;
      }
    }
  }
}


------------------------DAA029------------------------

// O programa deverá receber um conjunto de palavras ordenadas
// associadas a uma dada sequência de ordem das letras
// e determinar qual é essa sequência.

import java.util.*;
import java.io.*;

public class DAA029 {
  static int MAX = 26;
  static int n;
  static String words[] = new String[101];
  static boolean connected[] = new boolean[MAX];
  static ArrayList<Character> output = new ArrayList<Character>();
  static boolean adj[][] = new boolean[MAX][MAX];    // Matriz de adjacencias
  static boolean visited[] = new boolean[MAX]; // Que nos ja foram visitados?

  static void buildGraph(String[] words) {
    for (int i=0; i<n-1; i++)
      for (int c=0; c < (int)words[i].length() && c < (int)words[i+1].length(); c++)
        if (words[i].charAt(c) != words[i+1].charAt(c)) {
          adj[words[i].charAt(c)-'A'][words[i+1].charAt(c)-'A'] = true;
          connected[words[i].charAt(c)-'A'] = true;
          connected[words[i+1].charAt(c)-'A'] = true;
          break;
        }
  }

  static void dfs(int v) {
    visited[v] = true;
    for (int j=0; j<MAX; j++)
      if (adj[v][j] && !visited[j])
        dfs(j);
    output.add(0, (char)v);
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    n = in.nextInt();
    for (int i=0; i<n; i++)
      words[i] = in.next();

    buildGraph(words);

    for (int i=0; i<MAX; i++) {
      if (connected[i] && !visited[i])
        dfs(i);
    }

    for (int j : output) {
      System.out.print((char)(j+'A'));
    }
    System.out.println();
  }
}


------------------------BFS------------------------

// Exemplo de pesquisa em largura (BFS) num grafo nao dirigido
// (similar ao codigo feito na teorica - inclui calculo de distancias)

import java.io.*;
import java.util.*;

// Classe que representa um no
class Node {
    public LinkedList<Integer> adj; // Lista de adjacencias
    public boolean visited;         // Valor booleano que indica se foi visitado numa pesquisa
    public int distance;            // Distancia ao no origem da pesquisa

    Node() {
       adj = new LinkedList<Integer>();
    }
}

// Classe que representa um grafo
class Graph {
    int n;           // Numero de nos do grafo
    Node nodes[];    // Array para conter os nos

    Graph(int n) {
      this.n = n;
      nodes  = new Node[n+1]; // +1 se nos comecam em 1 ao inves de 0
      for (int i=1; i<=n; i++)
        nodes[i] = new Node();
    }

    public void addLink(int a, int b) {
      nodes[a].adj.add(b);
      nodes[b].adj.add(a);
    }

    // Algoritmo de pesquisa em largura
    public void bfs(int v) {
      LinkedList<Integer> q = new LinkedList<Integer>();
      for (int i=1; i<=n; i++)
        nodes[i].visited = false;

      q.add(v);
      nodes[v].visited = true;
      nodes[v].distance = 0;

      while (q.size() > 0) {
        int u = q.removeFirst();
        System.out.println(u + " [dist=" + nodes[u].distance + "]");
        for (int w : nodes[u].adj)
          if (!nodes[w].visited) {
            q.add(w);
            nodes[w].visited  = true;
            nodes[w].distance = nodes[u].distance + 1;
          }
      }
   }
}

public class BFS {
  public static void main(String args[]) {
    Scanner in = new Scanner(System.in);

    Graph g = new Graph(in.nextInt());
    int   e = in.nextInt();
    for (int i=0; i<e; i++)
      g.addLink(in.nextInt(), in.nextInt());

    // Pesquisa em largura a partir do no 1
    g.bfs(1);   
  }
}


------------------------DAA030------------------------


// Dado um grafo conexo não dirigido e não pesado descrevendo uma rede biológica,
// calcular o seu diâmetro, raio, nós centrais e quais os nós periféricos.

import java.util.*;
import java.io.*;

public class DAA030 {
    public static int MAX = 1500;
    public static int matriz[][] = new int[MAX+1][MAX+1];

    static class Node {
        public LinkedList<Integer> adj;  // Lista de adjacencias
        public boolean visited;      // Valor booleano que indica se foi visitado numa pesquisa
        public int distance;         // Distancia ao no origem da pesquisa

        Node() {
          adj = new LinkedList<Integer>();
        }
    }

    static class Graph {
        int n;          // Numero de nos do grafo
        Node nodes[];    // Array para conter os nos

        Graph(int n) {
            this.n = n;
            nodes = new Node[n+1];  // +1 se os comecam em 1 ao inves de
            for (int i=1; i<=n; i++)
              nodes[i] = new Node();
        }

        public void addLink(int a, int b) {
            nodes[a].adj.add(b);
            nodes[b].adj.add(a);
        }

        public void bfs(int v) {
            LinkedList<Integer> q = new LinkedList<Integer>();
            for (int i=1; i<=n; i++)
                nodes[i].visited = false;
            q.add(v);
            nodes[v].visited = true;
            nodes[v].distance = 0;
            matriz[v][v] = 0;

            while (q.size() > 0) {
              int u = q.removeFirst();
              for (int w : nodes[u].adj)
                if (!nodes[w].visited) {
                  q.add(w);
                  nodes[w].visited  = true;
                  nodes[w].distance = nodes[u].distance + 1;
                  matriz[v][w] = nodes[w].distance;
                }
            }
        }
    }

    public static int excentricidade (int v, int n) {
      int max = 0;
      for (int i=1; i<=n; i++)
        if (max <= matriz[v][i])
          max = matriz[v][i];
      return max;
    }


    public static void main(String[] args){
      Scanner in = new Scanner(System.in);
      int a, b, exc;
      int diam = 0;
      int raio = Integer.MAX_VALUE;

      Set<Integer> centrais    = new TreeSet<Integer>(); //TreeSet sorts elements
      Set<Integer> perifericos = new TreeSet<Integer>();

      int n = in.nextInt();
      Graph g = new Graph(n);

      int e = in.nextInt();
      for (int i=0; i<e; i++) {
        a = in.nextInt();
        b = in.nextInt();
        g.addLink(a, b);
      }

      for (int i=1; i<=n; i++)
          g.bfs(i);

      for (int i=1; i<=n; i++) {
        exc = excentricidade(i,n);
        if (diam <= exc)
          diam = exc;
        if (raio >= exc)
          raio = exc;
       }
       System.out.println(diam);
       System.out.println(raio);

       for (int i=1; i<=n; i++) {
        exc = excentricidade(i,n);
        if (raio == exc)
          centrais.add(i);
        if (diam == exc)
          perifericos.add(i);
       }

       int count = 0;
       for (int i : centrais) {
         count++;
         if (centrais.size() == count)
           System.out.print(i);
         else
           System.out.print(i + " ");
       }
       System.out.println();

       count = 0;
       for (int i : perifericos) {
         count++;
         if (perifericos.size() == count)
           System.out.print(i);
         else
           System.out.print(i + " ");
       }
       System.out.println();
     }
}


------------------------Dijkstra------------------------

// Exemplo de aplicacao do algoritmo de Dijkstra
// (assumindo um grafo pesado e dirigido, sem pesos negativos)
// (codigo adaptado do codigo em C++ feito na teorica)

import java.util.*;

// Classe que representa uma aresta
class Edge {
    int to;     // No destino
    int weight; // Peso da aresta

    Edge(int t, int w) {
      to = t;
      weight = w;
    }
}

// Classe que representa um no
class Node {
    public LinkedList<Edge> adj; // Lista de adjacencias
    public boolean visited;      // No ja foi visitado?
    public int distance;         // Distancia ao no origem da pesquisa

    Node() {
       adj = new LinkedList<>();
    }
};

// Classe que representa um no para ficar na fila de prioridade
class NodeQ implements Comparable<NodeQ> {
    public int cost;
    public int node;

    NodeQ(int c, int n) {
      cost = c;
      node = n;
    }

    @Override
    public int compareTo(NodeQ nq) {
        if (cost < nq.cost) return -1;
        if (cost > nq.cost) return +1;
        if (node < nq.node) return -1;
        if (node > nq.node) return +1;
        return 0;
    }
}

// Classe que representa um grafo
class Graph {
    int n;          // Numero de nos do grafo
    Node[] nodes;   // Array para conter os nos

    Graph(int n) {
      this.n = n;
      nodes = new Node[n+1];  // +1 se os nos comecam em 1 ao inves de 0
      for (int i=1; i<=n; i++)
         nodes[i] = new Node();
    }

    void addLink(int a, int b, int c) {
       nodes[a].adj.add(new Edge(b, c));
    }

    // Algoritmo de Dijkstra
    void dijkstra(int s) {

      //Inicializar nos como nao visitados e com distancia infinita
      for (int i=1; i<=n; i++) {
          nodes[i].distance = Integer.MAX_VALUE;
          nodes[i].visited  = false;
      }

      // Inicializar "fila" com no origem
      nodes[s].distance = 0;
      TreeSet<NodeQ> q = new TreeSet<>();
      q.add(new NodeQ(0, s)); // Criar um par (dist=0, no=s)

      // Ciclo principal do Dijkstra
      while (!q.isEmpty()) {

        // Retirar no com menor distancia (o "primeiro" do set, que e uma BST)
        NodeQ nq = q.pollFirst();
        int    u = nq.node;
        nodes[u].visited = true;
        System.out.println(u + " [dist=" + nodes[u].distance + "]");

        // Relaxar arestas do no retirado
        for (Edge e : nodes[u].adj) {
          int v = e.to;
          int cost = e.weight;
          if (!nodes[v].visited && nodes[u].distance + cost < nodes[v].distance) {
              q.remove(new NodeQ(nodes[v].distance, v)); // Apagar do set
              nodes[v].distance = nodes[u].distance + cost;
              q.add(new NodeQ(nodes[v].distance, v));    // Inserir com nova (e menor) distancia
          }
        }
      }
    }
};


public class dijkstra {
  public static void main(String args[]) {
  Scanner in = new Scanner(System.in);

  Graph g = new Graph(in.nextInt());
  int   e = in.nextInt();
  for (int i=0; i<e; i++)
    g.addLink(in.nextInt(), in.nextInt(), in.nextInt());

    // Execucao exemplo a partir do no 1
    g.dijkstra(1);
  }
}


------------------------DAA033------------------------

// Dado um mapa de de estradas, a localização duma casa e a das aulas teóricas, 
// escrever um programa indicando qual a distância mínima desde a casa até às aulas

import java.lang.*;
import java.io.*;
import java.util.*;

// Classe que representa uma aresta
class Edge {
    int to;     // No destino
    float weight; // Peso da aresta

    Edge(int t, float w) {
      to = t;
      weight = w;
    }
}

// Classe que representa um no
class Node {
    public LinkedList<Edge> adj; // Lista de adjacencias
    public boolean visited;      // No ja foi visitado?
    public float distance;         // Distancia ao no origem da pesquisa

    Node() {
       adj = new LinkedList<>();
    }
};

// Classe que representa um no para ficar na fila de prioridade
class NodeQ implements Comparable<NodeQ> {
    public float cost;
    public int node;

    NodeQ(float c, int n) {
      cost = c;
      node = n;
    }

    @Override
    public int compareTo(NodeQ nq) {
        if (cost < nq.cost) return -1;
        if (cost > nq.cost) return +1;
        if (node < nq.node) return -1;
        if (node > nq.node) return +1;
        return 0;
    }
}

// Classe que representa um grafo
class Graph {
    int n;          // Numero de nos do grafo
    Node[] nodes;   // Array para conter os nos

    Graph(int n) {
      this.n = n;
      nodes = new Node[n+1];  // +1 se os nos comecam em 1 ao inves de 0
      for (int i=1; i<=n; i++)
      nodes[i] = new Node();
    }

    void addLink(int a, int b, float c) {
       nodes[a].adj.add(new Edge(b, c));
    }

    // Algoritmo de Dijkstra
    void dijkstra(int s) {

      //Inicializar nos como nao visitados e com distancia infinita
      for (int i=1; i<=n; i++) {
          nodes[i].distance = Integer.MAX_VALUE;
          nodes[i].visited  = false;
      }

      // Inicializar "fila" com no origem
      nodes[s].distance = 0;
      TreeSet<NodeQ> q = new TreeSet<>();
      q.add(new NodeQ(0, s)); // Criar um par (dist=0, no=s)

      // Ciclo principal do Dijkstra
      while (!q.isEmpty()) {

        // Retirar no com menor distancia (o "primeiro" do set, que e uma BST)
        NodeQ nq = q.pollFirst();
        int    u = nq.node;
        nodes[u].visited = true;

        // Relaxar arestas do no retirado
        for (Edge e : nodes[u].adj) {
          int v = e.to;
          float cost = e.weight;
          if (!nodes[v].visited && nodes[u].distance + cost < nodes[v].distance) {
              q.remove(new NodeQ(nodes[v].distance, v)); // Apagar do set
              nodes[v].distance = nodes[u].distance + cost;
              q.add(new NodeQ(nodes[v].distance, v));    // Inserir com nova (e menor) distancia
          }
        }
      }
      System.out.printf("%.1f\n", nodes[2].distance);
    }
};


public class DAA033 {
  public static void main(String args[]) {
  Scanner in = new Scanner(System.in);

  Graph g = new Graph(in.nextInt());
  int   e = in.nextInt();
  in.nextLine();
  String s[] = in.nextLine().split(" "); //origem e destino
  TreeMap <String,Integer> roads = new TreeMap<String,Integer>(); //mapa das estradas
  int places = 0;
  roads.put(s[0], ++places);
  roads.put(s[1], ++places);

  for (int i=0; i<e; i++) {
    String[] map = in.nextLine().split(" ");
    int pointA, pointB;

    if(!roads.containsKey(map[0])) {
      pointA = ++places;
      roads.put(map[0], pointA);
    } else pointA = roads.get(map[0]);

    if(!roads.containsKey(map[1])) {
      pointB = ++places;
      roads.put(map[1], pointB);
    } else pointB = roads.get(map[1]);

    g.addLink(pointA, pointB, Float.parseFloat(map[2]));
    g.addLink(pointB, pointA, Float.parseFloat(map[2]));
  }

    // Execucao a partir do no origem
    g.dijkstra(1);
  }
}


------------------------DAA035------------------------

// descobrir que cidades estão ligadas por voos, directamente/indirectamente,
// através de outros voos, passando por cidades intermédias

//Incompleto!
import java.util.*;

// Classe que representa um no
class Node {
    public LinkedList<Integer> adj; // Lista de adjacencias

    Node() {
        adj = new LinkedList<>();
    }
}

// Classe que representa um grafo
class Graph {
    int n;          // Numero de nos do grafo
    Node[] nodes;   // Array para conter os nos

    Graph(int n) {
      this.n = n;
      nodes = new Node[n+1];  // +1 se os nos comecam em 1 ao inves de 0
      for (int i=1; i<=n; i++)
         nodes[i] = new Node();
    }

    void addLink(int a, int b) {
        nodes[a].adj.add(b);
    }

    void floydWarshall() {
      boolean connected[][] = new boolean[n+1][n+1];

      for(int i=0; i<=n; i++)
        Arrays.fill(connected[i], false);

      for(int i=1; i<=n; i++) {
        connected[i][i] = true;
        for (int e : nodes[i].adj)
          connected[i][e] = true;
      }

      for (int i=1; i<=n; i++)
        for (int j=1; j<=n; j++)
          for (int k=1; k<=n; k++)
            if (connected[i][k] && connected[k][j])
               connected[i][j] = true;

      System.out.print(" ");
      for (int i=1; i<=n; i++)
        System.out.print(" " + (char)(i+64));

      System.out.println();

      for (int i=1; i<=n; i++) {
        System.out.print((char)(i+64));
        for (int j=1; j<=n; j++) {
          int result = 0;
          if (connected[i][j]) result = 1;
          System.out.print(" " + result);
        }
        System.out.println();
      }
   }
}


public class DAA035 {
    public static void main(String args[]) {
      Scanner in = new Scanner(System.in);

      int v = in.nextInt(); //num cidades
      Graph g = new Graph(v);
      in.nextLine();

      for (int i=0; i<v; i++) {
        String[] s = in.nextLine().split(" ");
        int origem = (int)(s[0].charAt(0))-65;
        int e = Character.getNumericValue(s[1].charAt(0));
        for (int j=0; j<e; j++) {
          int destino = (int)(s[j+2].charAt(0))-65;
          g.addLink(origem+1, destino+1);
        }
      }
      g.floydWarshall();
  }
}


------------------------DAA034------------------------

// verificar a existencia dos ciclos negativos 

import java.util.*;

// Classe que representa uma aresta
class Edge {
    int to;     // No destino
    int weight; // Peso da aresta

    Edge(int t, int w) {
      to = t;
      weight = w;
    }
}

// Classe que representa um no
class Node {
    public LinkedList<Edge> adj; // Lista de adjacencias
    public boolean visited;      // No ja foi visitado?
    public int distance;         // Distancia ao no origem da pesquisa

    Node() {
       adj = new LinkedList<>();
    }
}

// Classe que representa um no para ficar na fila de prioridade
class NodeQ implements Comparable<NodeQ> {
    public int cost;
    public int node;

    NodeQ(int c, int n) {
      cost = c;
      node = n;
    }

    @Override
    public int compareTo(NodeQ nq) {
        if (cost < nq.cost) return -1;
        if (cost > nq.cost) return +1;
        if (node < nq.node) return -1;
        if (node > nq.node) return +1;
        return 0;
    }
}

// Classe que representa um grafo
class Graph {
    int n;          // Numero de nos do grafo
    int edges;
    Node[] nodes;   // Array para conter os nos

    Graph(int n, int e) {
      this.n = n;
      edges  = e;
      nodes = new Node[n+1];  // +1 se os nos comecam em 1 ao inves de 0
      for (int i=1; i<=n; i++)
        nodes[i] = new Node();
    }

    void addLink(int a, int b, int c) {
       nodes[a].adj.add(new Edge(b, c));
    }

    int bellmanFord(int s) {
      for (int i=1; i<=n; i++)
        nodes[i].distance = Integer.MAX_VALUE/2; //para evitar overflow

      for (int i=1; i<n; i++) {
        for (int j=1; j<=n; j++) {
          for (Edge e : nodes[j].adj) {
            int v    = e.to;
            int cost = e.weight;
            if (nodes[j].distance + cost < nodes[v].distance)
              nodes[v].distance = nodes[j].distance + cost;
          }
        }
      }

      for (int j=1; j<=n; j++) {
        for (Edge e : nodes[j].adj) {
          int v    = e.to;
          int cost = e.weight;
          if (nodes[j].distance + cost < nodes[v].distance)
            return -1;
        }
      }
      return 0;
    }
}


public class DAA034 {
    public static void main(String args[]) {
    Scanner in = new Scanner(System.in);
    int n = in. nextInt();

    for (int i=0; i<n; i++) {
      int v = in.nextInt();  //sistemas estrelares
      int e = in.nextInt();  //buracos negros
      Graph g = new Graph(v, e);

      for (int j=0; j<e; j++)
        g.addLink(in.nextInt()+1, in.nextInt()+1, in.nextInt());

      if (g.bellmanFord(1) == 0)
        System.out.println("impossivel");
      else
        System.out.println("possivel");
    }
  }
}


------------------------Detecao de ciclos em grafos------------------------

Vamos usar 3 cores:
Branco - No nao visitado
Cinzento - No a ser visitado (ainda estamos a explorar descendentes)
Preto - No ja visitado (ja visitamos todos os descendentes)

Detecao de Ciclos - O(|V| + |E|) (lista) ou O(|V|^2) (matriz)

cor[v ∈ V ] ← branco
Para todos os nos v do grafo fazer
  Se cor [v] = branco entao
    dfs(v)

dfs(no v):
  cor[v] ← cinzento
  Para todos os nos w adjacentes a v fazer
    Se cor[w] = cinzento entao
      escrever(”Ciclo encontrado!”)
    Senao se cor[w] = branco entao
      dfs(w)
  cor[v] ← preto


------------------------Pontos de articulacao grafos------------------------

Uma ideia:
Aplicar DFS no grafo e obter a arvore de DFS
Se um no v tem um filho w que nao tem nenhum caminho para
um antecessor de v, entao v ́e um ponto de articulacao! (pois
retira-lo desliga w do resto do grafo)
  Isto corresponde a verificar que low [w] ≥ num[v]
A unica excepcao e a raız da pesquisa. Se tiver mais que um filho...
entao é tambem ponto de articulacao!

Algoritmo:

dfs_art(no v):
  num[v] ← low [v] ← index; 
  index ← index + 1; 
  S.push(v)
  Para todos os nos w adjacentes a v fazer
    Se num[w] ainda nao esta definido entao   /* Tree Edge */
      dfs art(w); low [v] ← min(low [v], low [w])
      Se low [w] ≥ num[v] entao
        escrever(v + ” ́e um ponto de articulacao”)
    Senao se w esta em S entao                /* Back Edge */
      low [v] ← min(low[v], num[w])
  S.pop()



































------------------------CHEAT SHEET DO TESTE 1!!------------------------


------------------------SubconjuntosArray------------------------

// Escrever todos os subconjuntos do array v[]
public class TestSets {
   
   static void sets(int v[]) {
      // array de booleanos para representar o conjunto
      boolean used[] = new boolean[v.length];
      goSets(0, v, used); // chamar funcao recursiva
   }

   // Gera todos os subconjuntos a partir da posicao 'cur'
   static void goSets(int cur, int v[], boolean used[]) {
      if (cur == v.length) {  // Caso base: terminamos o conjunto
         // Escrever conjunto
         System.out.print("Set:");
         for (int i=0; i<v.length; i++) 
            if (used[i]) System.out.print(" " + v[i]);
         System.out.println();
      } else {                  // Se nao terminamos, continuar a gerar
         used[cur] = true;      // Subconjuntos que incluem o elemento actual
         goSets(cur+1, v, used);// Chamada recursiva
         used[cur] = false;     // Subconjuntos que nao incluem o el. actual
         goSets(cur+1, v, used);// Chamada recursiva
      }
   }   
   public static void main(String[] args) {
      int v[] = {2,4,6,8}; // Inicializacao de array
      sets(v);
   }
}



------------------------PermutacoesArray------------------------

// Escrever todos as permutacoes do array v[]
public class TestPerm {
    static void permutations(int v[]) {
    boolean used[] = new boolean[v.length]; // $i$ esta na permutacao?
    int perm[] = new int[v.length];         // permutacao actual
    goPerm(0, v, used, perm); // chamar funcao recursiva
    }
    // Gera todos os subconjuntos a partir da posicao 'cur'
    static void goPerm(int cur, int v[], boolean used[], int perm[]) {
    if (cur == v.length) {  // Caso base: terminamos a permutacao
        for (int i=0; i<v.length; i++) // Escrever a permutacao
  System.out.print(v[perm[i]] + " ");
      System.out.println();
  } else { // Se nao terminamos, continuar a gerar
      for (int i=0; i<v.length; i++) // Tentar todos os elementos
      if (!used[i]) { 
          used[i] = true; perm[cur] = i;
          goPerm(cur+1, v, used, perm);
          used[i] = false;
      }
      }
    }   

   public static void main(String[] args) {
      int v[] = {2,4,6,8}; // Inicializacao de array
      permutations(v);
   }
}



------------------------MaxElemArray------------------------

// Os 3 metodos seguintes recebem array v[] e duas posicoes start e end
// e devolvem o maior numero do array entre start e end (inclusive)
public class TestMax {
   
   // Versao iterativa   
   static int maxIt(int v[], int start, int end) {
      int maxSoFar = v[start];                // Maior ate agora
      for (int i=start+1; i<=end; i++)        // Percorrer intervalo
         maxSoFar = Math.max(maxSoFar, v[i]); // Actualizar maximo
      return maxSoFar;
   }
   
   // Versao recursiva 1: dividir em elemento inicial e resto da lista
   static int maxRec1(int v[], int start, int end) {
      if (start == end) return v[start];  // caso base (tamanho 1)
      int max = maxRec1(v, start+1, end); // chamada recursiva (resto da lista)
      return Math.max(v[start], max);     // combinar resultado
   }
   
   // Versao recursiva 2: dividir em metade esquerda e metade direita
   static int maxRec2(int v[], int start, int end) {
      if (start == end) return v[start];    // caso base (tamanho 1)
      int middle = (start + end) / 2;       // ponto medio
      int max1 = maxRec2(v, start, middle); // recursao na metade esquerda
      int max2 = maxRec2(v, middle+1, end); // recursao na metade direita
      return Math.max(max1, max2);          // combinar resultado
   }
   
   public static void main(String[] args) {
      int v[] = {1,5,2,8,4,3,7,6}; // Inicializacao de array
      System.out.println("maxIt: " + maxIt(v, 0, v.length-1));
      System.out.println("maxRec1: " + maxRec1(v, 0, v.length-1));
      System.out.println("maxRec2: " + maxRec2(v, 0, v.length-1));
   }
}


---
Stable Sort: em caso de empate, manter ordem inicial



------------------------BubbleSort------------------------

void bubbleSort(int arr[]) {
  int n = arr.length;
  for (int i=0; i < n-1; i++) {
    for (int j=0; j < n-i-1; j++) {
      if (arr[j] > arr[j+1]) {
        // swap arr[j+1] and arr[j]
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}

/*
do
  swapped = false
  for i = 1 to indexOfLastUnsortedElement-1
    if leftElement > rightElement
      swap(leftElement, rightElement)
      swapped = true; ++swapCounter
while swapped
*/



------------------------SelectionSort------------------------

void selectionSort(int arr[]) {
  int n = arr.length;

  // One by one move boundary of unsorted subarray
  for (int i = 0; i < n-1; i++) {
    // Find the minimum element in unsorted array
    int min_idx = i;
    for (int j = i+1; j < n; j++)
      if (arr[j] < arr[min_idx])
        min_idx = j;

    // Swap the found minimum element with the first element
    int temp = arr[min_idx];
    arr[min_idx] = arr[i];
    arr[i] = temp;
  }
}

/*
repeat (numOfElements - 1) times
  set the first unsorted element as the minimum
  for each of the unsorted elements
    if element < currentMinimum
      set element as new minimum
  swap minimum with first unsorted position
*/



------------------------InsertionSort------------------------

void insertionSort(int arr[]) {
  int n = arr.length;
  for (int i = 1; i < n; ++i) {
    int key = arr[i];
    int j = i - 1;

    /* Move elements of arr[0..i-1], that are
       greater than key, to one position ahead
       of their current position */
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = key;
  }
}

/*
mark first element as sorted
for each unsorted element X
  'extract' the element X
  for j = lastSortedIndex down to 0
    if current element j > X
      move sorted element to the right by 1
    break loop and insert X here
*/



------------------------QuickSort-Java------------------------

static void swap(int[] arr, int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

/* This function takes last element as pivot, places
the pivot element at its correct position in sorted
array, and places all smaller (smaller than pivot)
to left of pivot and all greater elements to right
of pivot */
static int partition(int[] arr, int low, int high) {
  
  int pivot = arr[high];
  
  // Index of smaller element and
  // indicates the right position of pivot found so far
  int i = (low - 1);

  for(int j = low; j <= high - 1; j++) {
    // If current element is smaller than the pivot
    if (arr[j] < pivot) {
      // Increment index of smaller element
      i++;
      swap(arr, i, j);
    }
  }
  swap(arr, i + 1, high);
  return (i + 1);
}

static void quickSort(int[] arr, int low, int high) {
  if (low < high) {
    // pi is partitioning index, arr[pi] is now at right place
    int pi = partition(arr, low, high);

    // Separately sort elements before partition and after partition
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
}


/*
for each (unsorted) partition
set first element as pivot //or randomly select pivot and swap with 1st elem
  storeIndex = pivotIndex+1
  for i = pivotIndex+1 to rightmostIndex
    if ((a[i] < a[pivot]) or (equal but 50% lucky))
      swap(i, storeIndex); ++storeIndex
  swap(pivot, storeIndex-1)
*/



------------------------RandomizedQuickSort------------------------

import java.util.*;

class RandomizedQsort { 
  // calculating random numbers between low and high (inclusive)
  static void random(int arr[], int low, int high) {
    Random rand = new Random();
    int pivot = rand.nextInt(high-low)+low;
    int temp1 = arr[pivot];
    arr[pivot] = arr[high];
    arr[high] = temp1;
  }
  
  static int partition(int arr[], int low, int high) {
    // pivot is chosen randomly
    random(arr,low,high);
    int pivot = arr[high];
  
    int i = (low-1); // index of smaller element
    for (int j = low; j < high; j++) {
      if (arr[j] < pivot) {
        i++;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }

    // swap arr[i+1] and arr[high] (or pivot)
    int temp = arr[i+1];
    arr[i+1] = arr[high];
    arr[high] = temp;

    return i+1;
  }

  static void sort(int arr[], int low, int high) {
    if (low < high) {
      int pi = partition(arr, low, high);
      // Recursively sort elements before and after partition
      sort(arr, low, pi-1);
      sort(arr, pi+1, high);
    }
  }

  static void printArray(int arr[]) {
    int n = arr.length;
    for (int i = 0; i < n; ++i)
      System.out.print(arr[i]+" ");
    System.out.println();
  }

  public static void main(String args[]) {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = arr.length;

    sort(arr, 0, n-1);

    System.out.println("Sorted array");
    printArray(arr);
  }
}



------------------------MergeSort-C------------------------

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r) {
  int i, j, k;
  int n1 = m - l + 1;
  int n2 = r - m;

  /* create temp arrays */
  int L[n1], R[n2];

  /* Copy data to temp arrays L[] and R[] */
  for (i = 0; i < n1; i++)
    L[i] = arr[l + i];
  for (j = 0; j < n2; j++)
    R[j] = arr[m + 1 + j];

  /* Merge the temp arrays back into arr[l..r]*/
  i = 0; // Initial index of first subarray
  j = 0; // Initial index of second subarray
  k = l; // Initial index of merged subarray
  while (i < n1 && j < n2) {
    if (L[i] <= R[j]) {
      arr[k] = L[i];
      i++;
    }
    else {
      arr[k] = R[j];
      j++;
    }
    k++;
  }

  /* Copy the remaining elements of L[], if there are any */
  while (i < n1) {
    arr[k] = L[i];
    i++;
    k++;
  }

  /* Copy the remaining elements of R[], if there are any */
  while (j < n2) {
    arr[k] = R[j];
    j++;
    k++;
  }
}

/* l is for left index and r is right index of the 
sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r) {
  if (l < r) {
    int m = l + (r - l) / 2;
    // Sort first and second halves
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);

    merge(arr, l, m, r);
  }
}


/*
split each element into partitions of size 1
recursively merge adjacent partitions
  for i = leftPartIdx to rightPartIdx
    if leftPartHeadValue <= rightPartHeadValue
      copy leftPartHeadValue
    else: copy rightPartHeadValue; Increase InvIdx
copy elements back to original array
*/



------------------------MergeSort-Java------------------------

import java.util.Arrays;
public class TestMergeSort {

   // Ordenar array v entre posicoes start e end
   static void mergeSort(int v[], int start, int end) {
      if (start == end) return;        // caso base (tamanho 1)
      int middle = (start + end) / 2;  // ponto medio
      mergeSort(v, start, middle);     // chamada recursiva a metade esquerda
      mergeSort(v, middle+1, end);     // chamada recursiva a metade direita
      merge(v, start, middle, end);    // combinar resultados
   }

   // Juntar duas metadas ja ordenadas
   static void merge(int v[], int start, int middle, int end) {
      int aux[] = new int[end-start+1]; // Novo array temporario
      
      int p1 = start;    // "Apontador" do array da metade esquerda
      int p2 = middle+1; // "Apontador" do array da metade direita
      int cur = 0;       // "Apontador" do array aux[] a conter juncao
      while (p1 <= middle && p2 <= end) { // Enquanto der para comparar
         if (v[p1] <= v[p2]) aux[cur++] = v[p1++]; // Escolher menor
         else aux[cur++] = v[p2++];                // e adicionar
      }
      while (p1<=middle) aux[cur++] = v[p1++]; // Adicionar o que resta
      while (p2<=end)    aux[cur++] = v[p2++];
      
      // Copiar array aux[] para v[]
      for (int i=0; i<cur; i++) v[start+i] = aux[i];
   }

   public static void main(String args[]) {
      int v[] = {1,5,2,8,4,3,7,6}; // Inicializacao de array

      System.out.println("Antes  do mergeSort: " + Arrays.toString(v));
      mergeSort(v, 0, v.length-1);
      System.out.println("Depois do mergeSort: " + Arrays.toString(v));
   }
}



------------------------CountingSort------------------------

void sort(char arr[]) {
  int n = arr.length;

  // The output character array that will have sorted arr
  char output[] = new char[n];

  // Create a count array to store count of individual
  // characters and initialize count array as 0
  int count[] = new int[256];
  for (int i = 0; i < 256; ++i)
    count[i] = 0;

  // store count of each character
  for (int i = 0; i < n; ++i)
    ++count[arr[i]];

  // Change count[i] so that count[i] now contains actual
  // position of this character in output array
  for (int i = 1; i <= 255; ++i)
    count[i] += count[i - 1];

  // Build the output character array
  // To make it stable we are operating in reverse order.
  for (int i = n - 1; i >= 0; i--) {
    output[count[arr[i]] - 1] = arr[i];
    --count[arr[i]];
  }

  // Copy the output array to arr, so that arr now
  // contains sorted characters
  for (int i = 0; i < n; ++i)
    arr[i] = output[i];
}


/*
create key (counting) array
for each element in list
  increase the respective counter by 1
for each counter, starting from smallest key
  while counter is non-zero
    restore element to list
    decrease counter by 1
*/



------------------------RadixSort------------------------

// A utility function to get maximum value in arr[]
static int getMax(int arr[], int n) {
  int mx = arr[0];
  for (int i = 1; i < n; i++)
    if (arr[i] > mx)
      mx = arr[i];
  return mx;
}

// A function to do counting sort of arr[] according to
// the digit represented by exp.
static void countSort(int arr[], int n, int exp) {
  int output[] = new int[n]; // output array
  int i;
  int count[] = new int[10];
  Arrays.fill(count, 0);

  // Store count of occurrences in count[]
  for (i = 0; i < n; i++)
    count[(arr[i] / exp) % 10]++;

  // Change count[i] so that count[i] now contains
  // actual position of this digit in output[]
  for (i = 1; i < 10; i++)
    count[i] += count[i - 1];

  // Build the output array
  for (i = n - 1; i >= 0; i--) {
    output[count[(arr[i] / exp) % 10] - 1] = arr[i];
    count[(arr[i] / exp) % 10]--;
  }

  // Copy the output array to arr[], so that arr[] now
  // contains sorted numbers according to current digit
  for (i = 0; i < n; i++)
    arr[i] = output[i];
}

// The main function to that sorts arr[] of size n using Radix Sort
static void radixSort(int arr[], int n) {
  // Find the maximum number to know number of digits
  int m = getMax(arr, n);

  // Do counting sort for every digit,
  // instead of passing digit number, exp is passed
  // exp is 10^i where i is current digit number
  for (int exp = 1; m / exp > 0; exp *= 10)
    countSort(arr, n, exp);
}


/*
create 10 buckets (queues) for each digit (0 to 9)
for each digit placing
  for each element in list
    move element into respective bucket
  for each bucket, starting from smallest digit
    while bucket is non-empty
      restore element to list
*/



------------------------CustomSort-C------------------------

// Ordenar primeiro por ordem crescente da idade, e em caso de empate por
// ordem crescente alfabetica do nome
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STRINGS 500
#define MAX_LENGTH  30

typedef struct {
  int age;
  char name[MAX_LENGTH+1]; // (+1) Espaco para o '\0' no final da string
} Person;

// Funcao para comparar dois elementos de um array (necessaria para o qsort)
// Esta funcao deve devolver:
//  - numero < 0 se elemento "a" for menor que elemento "b"
//  - numero > 0 se elemento "a" for maior que elemento "b"
//  - zero, se elemento "a" for igual ao elemento "b"
int comparePerson(const void *a, const void *b) {
  Person *p1 = (Person *)a;
  Person *p2 = (Person *)b;

  if (p1->age < p2->age) return -1;
  if (p1->age > p2->age) return +1;
  // strcmp e uma funcao que ja existe no C - veja o manual se nao conhece
  return strcmp(p1->name, p2->name);
}

/*
int compare_int(const void *a, const void *b) {
  int i1 = *((int *)a);
  int i2 = *((int *)b);

  if (i1 < i2) return -1;
  if (i1 > i2) return +1;
  return 0;
} 
qsort(v, 10, sizeof(int), compare_int);
*/

int main() {
  int i, n;
  Person v[MAX_STRINGS];
  
  // Ler n nomes
  scanf("%d", &n);
  for (i=0; i<n; i++)
    scanf("%d %s", &v[i].age, v[i].name);

  // Chamada ao sort padrao da linguagem C
  // qsort(array, quantidade_elementos, tamanho_um_elemento, funcao_comparar)
  qsort(v, n, sizeof(Person), comparePerson);
  
  for (i=0; i<n; i++)
    printf("%d %s\n", v[i].age, v[i].name);
  
  return 0;
}



------------------------CustomSort-Java------------------------

// Ordenar primeiro por ordem crescente da idade, e em caso de empate por
// ordem crescente alfabetica do nome
import java.io.*;
import java.util.*;
class Person implements Comparable<Person> {
    public int age;
    public String name;

    Person(int a, String n) {
      age = a;
      name = n;
    }

    // Definir como comparar dois elementos da classe Person
    // compareTo e uma funcao que compara objecto com outro objecto "p"
    // Esta funcao deve devolver:
    //  - numero < 0 se objecto for menor que objecto "p"
    //  - numero > 0 se objecto for maior que objecto "p"
    //  - zero, se objecto for igual ao objecto "p"
    @Override
    public int compareTo(Person p) {
      if (age < p.age) return -1;
      if (age > p.age) return +1;
      return name.compareTo(p.name);
    }
}
public class CustomSort {
  public static void main(String args[]) {
  Scanner stdin = new Scanner(System.in);

  int n      = stdin.nextInt();
  Person v[] = new Person[n];
  for (int i = 0; i < n; i++)
     v[i] = new Person(stdin.nextInt(), stdin.next());

  // Chamada ao sort padrao da linguagem Java
  // Usa o comparador padrao do tipo do array
  Arrays.sort(v);

  for (int i = 0; i < n; i++)
      System.out.println(v[i].age + " " + v[i].name);
  }
}



------------------------bsearch------------------------

void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))

  key − This is the pointer to the object that serves as key for the search, type-casted as a void*.

  base − This is the pointer to the first object of the array where the search is performed, type-casted as a void*.

  nitems − This is the number of elements in the array pointed by base.

  size − This is the size in bytes of each element in the array.

  compare − This is the function that compares two elements.

int cmpfunc(const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}

int values[] = { 5, 20, 29, 32, 63 };

int main () {
   int *item;
   int key = 32;
   item = (int*) bsearch (&key, values, 5, sizeof (int), cmpfunc);
   if(item != NULL) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   return(0);
}



------------------------BinarySearch------------------------

// recursive Binary Search in C - O(log n)
#include <stdio.h>

// returns location of x in given array arr[l..r] if present,
// otherwise -1
int binarySearch(int arr[], int l, int r, int x) {
  if (r >= l) {
    int mid = l + (r - l) / 2;

    // If the element is present at the middle
    if (arr[mid] == x)
      return mid;

    // If element is smaller than mid, 
    // then it can only be present in left subarray
    if (arr[mid] > x)
      return binarySearch(arr, l, mid - 1, x);

    // Else the element can only be present
    // in right subarray
    return binarySearch(arr, mid + 1, r, x);
  }

  return -1;
}

int main(void)
{
  int arr[] = { 2, 3, 4, 10, 40 };
  int n = sizeof(arr) / sizeof(arr[0]);
  int x = 10;
  int result = binarySearch(arr, 0, n - 1, x);
  (result == -1)
    ? printf("Element is not present in array")
    : printf("Element is present at index %d", result);
  return 0;
}



------------------------ED198------------------------

/*Dada uma sequência de N números inteiros, calcular a maior soma
que uma sequência contígua de um ou mais números da sequência pode formar.
*/
import java.util.Scanner;
public class ED198 {
  public static int soma(int v[], int n) {
    int best = 0;
    int maxBest = 0;
    for (int i=0; i<n; i++) {
      best = best + v[i];
      if (best < 0)
        best = 0;
      else if (best > maxBest)
        maxBest = best;
    }
    return maxBest;
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    int v[] = new int[n];

    for (int i=0; i<n; i++) {
      v[i] = in.nextInt();
    }
    System.out.println(soma(v, n));
  }
}



------------------------DAA002------------------------

/* Dados vários pares de inteiros Ni e Ki,
descobrir, para cada par, qual o menor número maior que Ni tal que
a soma dos seus dígitos seja exactamente Ki
*/
#include <stdio.h>
int soma(int a) {
  int soma = 0, m;
  while(a > 0) {
    m = a%10;
    soma = soma + m;
    a = a/10;
  }
  return soma;
}

int arr(int n, int k) {
  int res=0;
  int f=0, i=n+1, sum=0;
  while(f!=1) {
    sum = soma(i);
    if (sum == k) {
      res = i;
      f = 1;
    }
    i++;
  }
  return res;
}

int main() {
  int t; //n de casos
  int n; //numero a partir do qual contamos
  int k; //soma dos digitos pretendida

  scanf("%d", &t);
  int r[t]; //resultados, numero mais pequeno, que é > n e satisfaz k
  for (int i=0; i<t; i++) {
    scanf("%d %d", &n, &k);
    r[i] = arr(n, k);
  }

  for (int j=0; j<t; j++)
    printf("%d\n", r[j]);

  return 0;
}



------------------------DAA005------------------------

/*Dada uma sequência de N bakugans, descrita pelas energias Ei de cada um deles,
bem como uma série de F fotos, cada uma indicando as posições Ai e Bi, 
calcular, para cada foto, a soma das energias dos bakugans 
com posições no intervalo [Ai, Bi].
*/
#include <stdio.h>
int main() {
  int n; //n de bakugans
  int e; //energia de um bakugan
  int f; //n de fotos
  int a, b; //pos inicial e final da foto

  scanf("%d", &n);

  int energ[n]; //energias dos bakugans
  int soma_acc[n+1]; //somas acumuladas das energias

  for (int i=0; i<n; i++) {
    scanf("%d", &e);
    energ[i] = e;
  }

  for (int i=1; i<=n; i++) {
    soma_acc[i] = energ[i-1] + soma_acc[i-1];
  }

  scanf("%d", &f);
  for (int i=0; i<f; i++) {
    scanf("%d %d", &a, &b);
    printf("%d\n", soma_acc[b] - soma_acc[a-1]);
  }
  return 0;
}



------------------------DAA006------------------------

/*Dadas as coordenadas de um quadrado e um círculo,
descobrir qual a área da zona da interseção entre eles.
*/
import java.util.Scanner;
import java.lang.Math.*;

public class DAA006 {

  public static double intersecao (double qx, double qy, double ql,
                                  double cx, double cy, double cr) {
    if ((qx + ql <= cx - cr) || (cx + cr <= qx) ||
        (cy - cr >= qy + ql) || (qy >= cy + cr))
      return 0;  //nao se intersetam

    if ((cx + cr <= qx + ql) && (cx - cr >= qx) &&
        (cy + cr <= qy + ql) && (cy - cr >= qy))
      return Math.PI * cr * cr;  //circulo está dentro do quadrado

    if (Math.sqrt((qx - cx)*(qx - cx) + (qy + ql - cy)*(qy + ql - cy)) <= cr &&
       Math.sqrt((qx + ql - cx)*(qx + ql - cx) + (qy + ql - cy)*(qy + ql - cy)) <= cr &&
       Math.sqrt((qx - cx)*(qx - cx) + (qy - cy)*(qy - cy)) <= cr &&
       Math.sqrt((qx + ql - cx)*(qx + ql - cx) + (qy - cy)*(qy - cy)) <= cr)
      return (ql * ql); //quadrado está dentro do circulo

    double area = 0;
    if (ql > 0.001)
      area = area + intersecao(qx, qy, ql/2, cx, cy, cr)
                  + intersecao(qx + ql/2, qy, ql/2, cx, cy, cr)
                  + intersecao(qx + ql/2, qy + ql/2, ql/2, cx, cy, cr)
                  + intersecao(qx, qy + ql/2, ql/2, cx, cy, cr);
    return area;
  }

  public static void main(String[] args) {
    FastScanner in = new FastScanner(System.in);
    int n = in.nextInt();
    double[] res = new double[n];

    for (int i=0; i<n; i++) {
        int qx = in.nextInt();
        int qy = in.nextInt();
        int ql = in.nextInt();
        int cx = in.nextInt();
        int cy = in.nextInt();
        int cr = in.nextInt();

        res[i] = intersecao(qx, qy, ql, cx, cy, cr);
    }

    for (int i=0; i<n; i++) {
      //FastPrint.out.format("%.4f", res[i]);
      FastPrint.out.println(res[i]);
    }
    FastPrint.out.close();
  }
}



------------------------DAA009------------------------

/* Dado um fragmento de ADN alienígena, produzir uma listagem das letras 
que aparecem menos uma vez, ordenada por ordem decrescente da sua frequência 
(número de occorrências) e em caso de empate pela ordem 
em que aparecem primeiro no fragmento (primeira ocorrência de cada letra).
*/
import java.io.*;
import java.util.*;

class Letra implements Comparable<Letra> {
    public int freq; //frequencia de ocorrencia da letra
    public int pos;  //posicao da primeira ocorrencia no array
    public char rep; //representacao da letra

    Letra(int f, int p, char r) {
      freq = f;
      pos = p;
      rep = r;
    }

    @Override
     public int compareTo(Letra l) {
       if (freq < l.freq) return 1;
       if (freq > l.freq) return -1;
       if (pos <= l.pos) return -1;
       if (pos > l.pos) return 1;
       return 0;
     }
}

public class DAA009 {
  public static void main(String args[]) {
  Scanner stdin = new Scanner(System.in);

  int n=1; //num of unique letters
  Letra v[] = new Letra[26]; //descricao da cada letra do alfabeto

  String adn = stdin.nextLine();

  char r = adn.charAt(0);
  v[0] = new Letra(1, 0, r);

  outerloop:
  for(int i=1; i<adn.length(); i++) {
    r = adn.charAt(i);
    for (int j=0; j<n; j++) {
      if (v[j].rep == r) {
        v[j].freq++;
        continue outerloop;
      }
    }
    v[n] = new Letra(1, i, r); //i = posicao da 1ª ocorrencia
    n++;
  }

  Letra dna[] = new Letra[n]; //array só para letras presentes no input
  for(int k=0; k<n; k++) {
    dna[k] = v[k];
  }

  Arrays.sort(dna);

  for (int c = 0; c < n; c++)
      System.out.println(dna[c].rep + " " + dna[c].freq);
  }
}



------------------------DAA010------------------------

/* Dada um conjunto S de N números inteiros, e uma sequência de Q perguntas,
cada uma indicando um número Pi, descobrir qual é a soma de dois números
diferentes de S que está mais próxima do número Pi de cada pergunta.
*/
import java.io.*;
import java.util.*;

public class DAA010 {

  public static int upperBound(int somas[], int key, int low, int high) {
    int middle = 0;
    int max = high;
    while (low < high) {
      middle = low + (high - low) / 2;
      if (somas[middle] >= key)
        high = middle;
      else
        low = middle + 1;
    }
    if (low < max && somas[low] >= key)
      low++;
    if (low == 0)
      return somas[0];
    return somas[low-1];
  }

  public static int lowerBound(int somas[], int key, int low, int high) {
    int middle = 0;
    int max = high;
    while (low < high) {
      middle = low + (high - low) / 2;
      if (somas[middle] < key)
        low = middle + 1;
      else
        high = middle;
    }
    if (low < max && somas[low] <= key)
      low++;
    if (low == 0)
      return somas[0];
    return somas[low-1];
  }

  public static void main(String args[]) {
    Scanner in = new Scanner(System.in);

    int n = in.nextInt(); //tamanho do conjunto
    int v[] = new int[n]; //numeros distinos a considerar
    for (int i=0; i<n; i++) {
      v[i] = in.nextInt();
    }

    int q = in.nextInt(); //n de perguntas
    int p[] = new int[q]; //num aos que queremos encontrar somas mais proximas
    for (int j=0; j<q; j++) {
      p[j] = in.nextInt();
    }

    int m = n*n; //num maximo de somas possiveis
    int temp[] = new int[m];
    int c=0;

    for (int i=0; i<n-1; i++) {
      for (int j=i+1; j<n; j++) {
        temp[c] = v[i] + v[j];
        c++; //numero final das combinacoes de somas
      }
    }

    int somas[] = new int[c]; //somas de cada par dos numeros
    for (int i=0; i<c; i++) {
      somas[i] = temp[i];
    }

    Arrays.sort(somas);
    int aux1, aux2;

    for(int i=0; i<q; i++) {
      aux1 = lowerBound(somas, p[i], 0, c);
      aux2 = upperBound(somas, p[i], 0, c);

      if (p[i]-aux1 < aux2-p[i])
        System.out.println(aux1);

      else if (p[i]-aux1 > aux2-p[i])
        System.out.println(aux2);

      else if ((p[i]-aux1 == aux2-p[i]) && (aux1 != aux2))
        System.out.println(aux1 + " " + aux2);

      else
        System.out.println(aux1);
    }
  }
}



------------------------DAA011------------------------

/*Dado um conjunto de N distâncias, e P perguntas (queries),
cada uma indicando um número Ki de dias, calcular, para cada pergunta,
qual o caminho que minimiza a maior distância num único dia.
*/
import java.io.*;
import java.util.*;

public class DAA011 {
  public static boolean greedy (int v[], int n, int q, int max) {
    int i, j=0, sum=0, f=0;
    for (i=0; i<q; i++) {
      while (j < n && sum <= max) {
        sum = sum + v[j];
        j++;
        if (j == n && sum > max && i == (q-1)) //?? explain
          f = 1;
      }
      sum = 0; j--;
    }
    if (f == 1 || (i == q && j < n-1)) return false;
    else return true;
  }

  public static int bsearch (int v[], int n, int q) {
    int low = 1;
    int high = 0;
    int middle;
    for (int i=0; i<n; i++)
      high = high + v[i];

    while (low < high) {
      middle = low + (high - low) / 2;
      if (greedy(v, n, q, middle))
        high = middle;
      else
        low = middle + 1;
    }
    return low;
  }

  public static void main(String args[]) {
    Scanner in = new Scanner(System.in);

    int n = in.nextInt(); //n de distancias
    int v[] = new int[n]; //array de distancias
    for (int i=0; i<n; i++) {
      v[i] = in.nextInt();
    }

    int q = in.nextInt(); //numero de queries
    int p[] = new int[q]; //array de particoes
    for (int j=0; j<q; j++) {
      p[j] = in.nextInt();
    }

    for (int i=0; i<q; i++) {
      System.out.println(bsearch(v, n, p[i]));
    }
  }
}



------------------------DAA013------------------------

/*Dado um conjunto de N segmentos com coordenadas [Li, Ri] e um número M,
descobrir qual a menor quantidade de segmentos que cobrem o segmento [0,M].
*/
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int l; //inicio
  int r; //fim
} Segmento;

int compare_int(const void *a, const void *b) {
  int i1 = *((int *)a);
  int i2 = *((int *)b);

  if (i1 < i2) return -1;
  if (i1 > i2) return +1;
  return 0;
}

int main() {

  int m; //tamanho do segmento a cobrir
  int n; //quantidade de segmentos a considerar

  scanf("%d", &m);
  scanf("%d", &n);

  Segmento seg[n];

  for (int i=0; i<n; i++) {
    scanf("%d %d", &seg[i].l, &seg[i].r);
  }

  //ordenar por ordem crescente do seu inicio
  qsort(seg, n, sizeof(Segmento), compare_int);

  int end=0; //vamos cobrir [0, end]
  int i;
  int count=0; //num minimo de segmentos para cobrir [0, m]

  do {
    int melhor=0;
    for(i=0; i<n; i++) {
      if (seg[i].l <= end)
        if (seg[i].r > seg[melhor].r)
          melhor = i;
    }
    end = seg[melhor].r;
    count++;
  } while (end < m);

  printf("%d\n", count);

  return 0;
}



------------------------DAA014------------------------

/*Dado um conjunto de N encomendas de sapatos,
cada um com a respectiva duração e multa por dia,
determinar qual a ordem em que o sapateiro deve tratar das encomendas
de modo a pagar a menor multa possível.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  float racio; //multa por dia
  float dias;  //duração do fabrico de um par
  float multa; //valor a pagar por cada dia de atraso
  int id;      //id de um par de sapatos
} Sapatos;

int compare_float(const void *a, const void *b) {
  float i1 = *((float *)a);
  float i2 = *((float *)b);

  if (i1 < i2) return 1;
  if (i1 > i2) return -1;
  return 0;
}

int main() {
  int n; //numero das encomendas
  scanf("%d", &n);
  Sapatos pares[n];

  //qual é a ordem dos pares que minimiza a multa?
  //em caso de empate escolher a soluçao que comece pelo menor id

  for (int i=0; i<n; i++) {
    scanf("%f %f", &pares[i].dias, &pares[i].multa);
    pares[i].racio = (pares[i].multa / pares[i].dias);
    pares[i].id = i+1;
  }

  qsort(pares, n, sizeof(Sapatos), compare_float); //ordena pelo racio

  for (int i=0; i<n; i++) {
    if(i == n-1) printf("%d", pares[n-1].id);
    printf("%d ", pares[i].id);
  }
  return 0;
}



------------------------DAA017------------------------

/*Dada uma pirâmide com N camadas, e as pedras em falta nas camadas da pirâmide,
calcular o número de maneiras diferentes de subir a pirâmide até ao topo,
começando por qualquer pedra da primeira camada, evitando as pedras em falta.
*/
#include <stdio.h>
int main() {
  int n; //num de pedras na 1ª camada == num de niveis da piramide
  int d; //num de pedras em falta
  long long m=0; //resposta - num de maneiras diferentes de subir

  scanf("%d", &n);
  scanf("%d", &d);

  long long count[n+1][n+1]; //caminhos possiveis a partir de uma pedra
  int est[n+1][n+1];   //array das pedras estragadas
  int cam; //indice da camada
  int pos; //indice da posicao

  //inicializar tudo a zero
  for (int i=0; i<=n; i++) {
    for (int j=0; j<=n; j++) {
      est[i][j] = 0;
      count[i][j] = 0;
    }
  }

  count[1][1] = 1;

  for (int i=1; i<=d; i++) {
    scanf("%d %d", &cam, &pos);
    est[n-cam+1][pos] = 1; //assegurar que os indices sao os do enunciado
    if (cam == n && pos == 1)
      count[1][1] = 0; //se a pedra estragada esta no topo, nao ha caminhos
  }

  //preencher a piramide com somas do que esta acima e acima+esquerda
  for (int i=1; i<=n; i++) {
    for (int j=1; j<=i; j++) {
      if (est[i][j] != 1) { //se nao esta estragada
        count[i][j] = count[i][j] + count[i-1][j];
        count[i][j] = count[i][j] + count[i-1][j-1];
      }
    }
  }

  for (int j=0; j<=n; j++)
    m = m + count[n][j]; //percorrer a linha do fundo e somar todas as maneiras
  printf("%lld\n", m);
  return 0;
}



------------------------DAA018------------------------

/*Dado um conjunto de N moedas e uma série de P perguntas, 
cada uma indicando uma quantia Qi, indicar qual o menor número de moedas 
necessário para fazer cada quantia, e quais as moedas a usar em cada caso.
*/
import java.io.*;
import java.util.*;

public class DAA018 {
  public static final int INF = 10001;

  public static void main(String args[]) {
    Scanner in = new Scanner(System.in);

    int n = in.nextInt();  //n de tipos de moedas
    int tipos[] = new int[n];
    for (int i=0; i<n; i++)
      tipos[i] = in.nextInt();

    int p = in.nextInt(); //n de perguntas
    int quant[] = new int[p];
    for (int i=0; i<p; i++)
      quant[i] = in.nextInt();  //quantia que queremos criar

    int coins[] = new int[INF]; //num minimo para criar uma quantia
    coins[0] = 0;

    int use[] = new int[INF]; //respostas
    int i, j;

    for (int l=0; l<p; l++) { //imprimir para cada pergunta (int l)
      for (i=1; i<=quant[l]; i++) {
        coins[i] = INF;
        for (j=0; j<n; j++) {
          if (tipos[j] <= i && ((1 + coins[i-tipos[j]]) < coins[i])) {
            coins[i] = 1 + coins[i-tipos[j]];
            use[i] = tipos[j];
          }
        }
      }
      //exemplo do formato: 13: [2] 5 8
      System.out.print(quant[l] + ": [" + coins[quant[l]] + "] ");
      int s = quant[l];
      for (int k=0; k<coins[quant[l]]; k++) {
        if (k == coins[quant[l]]-1)
          System.out.print(use[s]); //para nao ter spacebar depois do ult numero
        else
          System.out.print(use[s] + " ");
        s = s - use[s];
      }
      System.out.println();
    }
  }
}



------------------------Elegant-Strings------------------------

#include <stdio.h>
int elegante(char arr[], int n) {
  if (n == 0) return n;
  for (int i=0; i<n; i=i+2) { //go to every odd position
    if (arr[i] == arr[i+1]) { //if next char is equal
      for (int j=i+1; j<n-1; j++) //shift all chars to the left
        arr[j] = arr[j+1]; //replace all chars with next char
      n--; //reduce size of arr
      i=i-2; //set i as the position we are at, again
    }
  }
  if (n % 2 == 0)
    return n;
  else
    return (n-1); //reduce size by one because its already elegant,
                  //apart from the parity of string
}

int main() {
  int n;     //num de chars em s
  scanf("%d", &n);
  char s[n]; //palavra s
  scanf("%s", s);

  int aux = elegante(s, n);
  printf("%d\n", n - aux);

  return 0;
}



------------------------Fractional-Knapsack------------------------
import java.io.*;
import java.util.*;
public class KnapsackDP {
    static int knapSack(int weightCap, int weights[], int values[], int i) {
      int index, weight;
      int matrix[][] = new int[i + 1][weightCap + 1];

      for (index = 0; index <= i; index++) {
        for (weight = 0; weight <= weightCap; weight++) {
          if (index == 0 || weight == 0)
            matrix[index][weight] = 0;
          else if (weights[index-1] <= weight)
            matrix[index][weight] = Math.max(values[index-1] +
            matrix[index-1][weight-weights[index-1]], matrix[index-1][weight]);
          else
            matrix[index][weight] = matrix[index-1][weight];
        }
      }
      return matrix[i][weightCap];
  }
    public static void main(String[] args) {
        int values[] = new int[] { 70, 20, 39, 37, 7, 5, 10 };
        int weights[] = new int[] { 31, 10, 20, 19, 4, 3, 6 };
        int weightCap = 50;
        int i = values.length;
        KnapsackDP myNapsack = new KnapsackDP();
        System.out.println(myNapsack.knapSack(weightCap, weights, values, i));
    }
}



------------------------Rain-Water-Histogram------------------------
import java.io.*;
import java.util.*;

public class RainWaterDP {
  // The Two-Pointer Approach
  public int efficientSolution(int[] heights) {
    int totalWater = 0;
    int leftPointer = 0;
    int rightPointer = heights.length - 1;
    int leftBound = 0;
    int rightBound = 0;

    while (leftPointer < rightPointer) {
      if (heights[leftPointer] <= heights[rightPointer]) {
        leftBound = Math.max(heights[leftPointer], leftBound);
        totalWater += leftBound - heights[leftPointer];
        leftPointer++;
      }
      else {
        rightBound = Math.max(heights[rightPointer], rightBound);
        totalWater += rightBound - heights[rightPointer];
        rightPointer--;
      }
    }
    return totalWater;
  }

  public static void main(String[]args) {
    // heights: the array representing the histogram
    int[] heights = new int[] {4, 2, 1, 3, 0, 1, 2};
    RainWaterDP rainWater = new RainWaterDP();
    System.out.println("Amount of water captured: " + rainWater.efficientSolution(heights));
    //answer = 6
  }
}



------------------------Eratosthenes-PrimeNumbers------------------------
import java.util.*;
public class SieveOfEratosthenes {
    void sieveOfEratosthenes(int limit) {
      boolean[] output = new boolean[limit + 1];
      for (int x = 0; x <= limit; x++) {
         output[x] = true;
      }
      output[0] = false;
      output[1] = false;

      for (int i=2; i<=Math.pow(limit, 0.5); i++) {
       if (output[i] == true) {
         for (int j=(int)Math.pow(i, 2); j<=limit; j=j+i)
           output[j] = false;
       }
      }

      List<Integer> result = new ArrayList<Integer>();
      for (int i=0; i<output.length; i++) {
        if (output[i] == true)
          result.add(i);
      }
      System.out.println(Arrays.toString(result.toArray()));
    }

    public static void main(String[] args) {
        int n = 7;
        SieveOfEratosthenes g = new SieveOfEratosthenes();
        g.sieveOfEratosthenes(n);
        // should return [2, 3, 5, 7]
    }
}



------------------------Job-Sequencing------------------------

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// A structure to represent a job
typedef struct Job {
  char id; // Job Id
  int dead; // Deadline of job
  int profit; // Profit if job is over before or on deadline
} Job;

// This function is used for sorting all jobs according to
// profit
int compare(const void* a, const void* b)
{
  Job* temp1 = (Job*)a;
  Job* temp2 = (Job*)b;
  return (temp2->profit - temp1->profit);
}

// Find minimum between two numbers.
int min(int num1, int num2)
{
  return (num1 > num2) ? num2 : num1;
}

// Returns minimum number of platforms required
void printJobScheduling(Job arr[], int n)
{
  // Sort all jobs according to decreasing order of profit
  qsort(arr, n, sizeof(Job), compare);
  //   sort(arr, arr+n, comparison);

  int result[n]; // To store result (Sequence of jobs)
  bool slot[n]; // To keep track of free time slots

  // Initialize all slots to be free
  for (int i = 0; i < n; i++)
    slot[i] = false;

  // Iterate through all given jobs
  for (int i = 0; i < n; i++) {
    // Find a free slot for this job (Note that we start
    // from the last possible slot)
    for (int j = min(n, arr[i].dead) - 1; j >= 0; j--) {
      // Free slot found
      if (slot[j] == false) {
        result[j] = i; // Add this job to result
        slot[j] = true; // Make this slot occupied
        break;
      }
    }
  }

  // Print the result
  for (int i = 0; i < n; i++)
    if (slot[i])
      printf("%c ", arr[result[i]].id);
}

// Driver code
int main()
{
  Job arr[] = { { 'a', 2, 100 },
        { 'b', 1, 19 },
        { 'c', 2, 27 },
        { 'd', 1, 25 },
        { 'e', 3, 15 } };
  int n = sizeof(arr) / sizeof(arr[0]);
  printf(
    "Following is maximum profit sequence of jobs \n");

  // Function call
  printJobScheduling(arr, n);
  return 0;
}


------
Interval Scheduling
Ordenar atividades por ordem crescente de tempo de finalização
Começar por G = {}
Ir adicionando a G a próxima atividade da lista com menor fi que não esteja sobreposta com nenhuma atividade de G



------------------------FibonacciDP------------------------

int fib(int n) {
  if(n==0 || n==1) return n;
  int f, f1, f2;
  f1 = 1;
  f2 = 0;
  for (int i=2; i<=n; i++) {
    f = f1 + f2;
    f2 = f1;
    f1 = f;
  }
  return f;
}



------
Piramide de Numeros
Max(i,j)
If i==n então
 retorna P[i][j]
else
 retorna P[i][j] + maximo(max(i+1,j),max(i+1,j+1))

dp:
Calcular()
Para i<-n-1 até 1 fazer
  para j<-1 até i fazer
   P[i][j] <- P[i][j] + maximo(P[i+1][j],P[i+1][j+1])



------
Subsequência crescente

Calcular()
 best[n] <- 1
 para i<- n-1 até 1 fazer
  best[i] <- 1
 para j<-i+1 até n fazer
  If num[j] > num[i] e 1+best[j] > best[i] então
     best[i] <- 1 + best[j]



------
Obras na estrada

Calcular():
Inicializar count[][] com zeros
count[L][C] ← 1
Para i ← L ate 1 fazer
Para j ← C ate 1 fazer
Se i < L e nao(obra(i, j, NORTE)) entao
count[i][j] ← count[i][j] + count[i + 1][j]
Se j < C e nao(obra(i, j, ESTE)) entao
count[i][j] ← count[i][j] + count[i][j + 1]



------
Jogo das pedras

Calcular():
Para i ← 0 ate N fazer
Se (i ≥ 1 e win[i − 1]=falso) ou
(i ≥ 3 e win[i − 3]=falso) ou
(i ≥ 8 e win[i − 8]=falso) entao
win[i] ← verdadeiro
Senao
win[i] ← falso



------
Distância de edição

Calcular():
Para i ← 0 ate |a| fazer de[i][0] ← i
Para j ← 0 ate |b| fazer de[0][j] ← j
Para i ← 1 ate |a| fazer
Para j ← 1 ate |j| fazer
Se (a[i] = b[j] entao valor ← 0
Senao valor ← 1
de[i][j] = minimo( de[i − 1][j − 1] + value,
de[i − 1][j] + 1,
de[i][j − 1] + 1)




